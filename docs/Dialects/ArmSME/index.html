<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>'arm_sme' Dialect - MLIR</title><meta name=description content="Multi-Level IR Compiler Framework"><meta name=generator content="Hugo 0.111.3"><link href=https://mlir.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://mlir.llvm.org/docs/Dialects/ArmSME/><link rel=stylesheet href=https://mlir.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script>
<link rel=stylesheet href=https://mlir.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script>
<script src=https://mlir.llvm.org/js/bundle.js></script>
<script type=text/javascript src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type=text/x-mathjax-config>
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$', '$'] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
    }
  });
</script><link rel=apple-touch-icon sizes=180x180 href="/apple-touch-icon.png?v=1"><link rel=icon type=image/png sizes=32x32 href="/favicon-32x32.png?v=1"><link rel=icon type=image/png sizes=16x16 href="/favicon-16x16.png?v=1"><link rel=manifest href="/site.webmanifest?v=1"><link rel=mask-icon href="/safari-pinned-tab.svg?v=1" color=#3775e0><link rel="shortcut icon" href="/favicon.ico?v=1"><meta name=msapplication-TileColor content="#2d89ef"><meta name=theme-color content="#ffffff"><link rel=icon href=/favicon.svg type=image/svg+xml sizes=any><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://mlir.llvm.org//mlir-logo.png width=40px align=absmiddle>
MLIR</div></h1><p class=description>Multi-Level IR Compiler Framework</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/mlir/31>Forums</a></li><li class=child><a href=https://discord.gg/xS7Z362>Chat</a></li></ul></li><li><a href=/getting_started/Debugging/>Debugging Tips</a></li><li><a href=/getting_started/Faq/>FAQ</a></li><li class=parent><a href=https://github.com/llvm/llvm-project/tree/main/mlir>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=/doxygen/>Doxygen</a></li><li class=child><a href=https://github.com/llvm/llvm-project/tree/main/mlir>GitHub</a></li></ul></li><li><a href="https://bugs.llvm.org/buglist.cgi?bug_status=__open__&amp;list_id=177877&amp;order=changeddate%20DESC%2Cpriority%2Cbug_severity&amp;product=MLIR&amp;query_format=specific">Bugs</a></li><li><a href=https://github.com/llvm/mlir-www/tree/main/website/static/LogoAssets>Logo Assets</a></li><li><a href=https://www.youtube.com/MLIRCompiler>Youtube Channel</a></li></ul></nav></div><div class=content-container><main><h1>'arm_sme' Dialect</h1><p>Basic dialect to target Arm SME architectures
This dialect contains the definitions necessary to target Arm SME
scalable matrix operations.</p><p>Sources:
<a href=https://developer.arm.com/documentation/ddi0616>https://developer.arm.com/documentation/ddi0616</a>
<a href=https://developer.arm.com/documentation/ddi0602/2023-03/SME-Instructions>https://developer.arm.com/documentation/ddi0602/2023-03/SME-Instructions</a></p><p><nav id=TableOfContents><ul><li><a href=#operation-definition>Operation definition</a><ul><li><a href=#arm_smecast_tile_to_vector-arm_smecasttiletovector><code>arm_sme.cast_tile_to_vector</code> (arm_sme::CastTileToVector)</a></li><li><a href=#arm_smecast_vector_to_tile-arm_smecastvectortotile><code>arm_sme.cast_vector_to_tile</code> (arm_sme::CastVectorToTile)</a></li><li><a href=#arm_smeget_tile_id-arm_smegettileid><code>arm_sme.get_tile_id</code> (arm_sme::GetTileID)</a></li><li><a href=#arm_smeintrld1bhoriz-arm_smeaarch64_sme_ld1b_horiz><code>arm_sme.intr.ld1b.horiz</code> (arm_sme::aarch64_sme_ld1b_horiz)</a></li><li><a href=#arm_smeintrld1bvert-arm_smeaarch64_sme_ld1b_vert><code>arm_sme.intr.ld1b.vert</code> (arm_sme::aarch64_sme_ld1b_vert)</a></li><li><a href=#arm_smeintrld1dhoriz-arm_smeaarch64_sme_ld1d_horiz><code>arm_sme.intr.ld1d.horiz</code> (arm_sme::aarch64_sme_ld1d_horiz)</a></li><li><a href=#arm_smeintrld1dvert-arm_smeaarch64_sme_ld1d_vert><code>arm_sme.intr.ld1d.vert</code> (arm_sme::aarch64_sme_ld1d_vert)</a></li><li><a href=#arm_smeintrld1hhoriz-arm_smeaarch64_sme_ld1h_horiz><code>arm_sme.intr.ld1h.horiz</code> (arm_sme::aarch64_sme_ld1h_horiz)</a></li><li><a href=#arm_smeintrld1hvert-arm_smeaarch64_sme_ld1h_vert><code>arm_sme.intr.ld1h.vert</code> (arm_sme::aarch64_sme_ld1h_vert)</a></li><li><a href=#arm_smeintrld1qhoriz-arm_smeaarch64_sme_ld1q_horiz><code>arm_sme.intr.ld1q.horiz</code> (arm_sme::aarch64_sme_ld1q_horiz)</a></li><li><a href=#arm_smeintrld1qvert-arm_smeaarch64_sme_ld1q_vert><code>arm_sme.intr.ld1q.vert</code> (arm_sme::aarch64_sme_ld1q_vert)</a></li><li><a href=#arm_smeintrld1whoriz-arm_smeaarch64_sme_ld1w_horiz><code>arm_sme.intr.ld1w.horiz</code> (arm_sme::aarch64_sme_ld1w_horiz)</a></li><li><a href=#arm_smeintrld1wvert-arm_smeaarch64_sme_ld1w_vert><code>arm_sme.intr.ld1w.vert</code> (arm_sme::aarch64_sme_ld1w_vert)</a></li><li><a href=#arm_smeintrmopa-arm_smeaarch64_sme_mopa><code>arm_sme.intr.mopa</code> (arm_sme::aarch64_sme_mopa)</a></li><li><a href=#arm_smeintrmopawide-arm_smeaarch64_sme_mopa_wide><code>arm_sme.intr.mopa.wide</code> (arm_sme::aarch64_sme_mopa_wide)</a></li><li><a href=#arm_smeintrmops-arm_smeaarch64_sme_mops><code>arm_sme.intr.mops</code> (arm_sme::aarch64_sme_mops)</a></li><li><a href=#arm_smeintrmopswide-arm_smeaarch64_sme_mops_wide><code>arm_sme.intr.mops.wide</code> (arm_sme::aarch64_sme_mops_wide)</a></li><li><a href=#arm_smeintrsmopawide-arm_smeaarch64_sme_smopa_wide><code>arm_sme.intr.smopa.wide</code> (arm_sme::aarch64_sme_smopa_wide)</a></li><li><a href=#arm_smeintrsmopswide-arm_smeaarch64_sme_smops_wide><code>arm_sme.intr.smops.wide</code> (arm_sme::aarch64_sme_smops_wide)</a></li><li><a href=#arm_smeintrst1bhoriz-arm_smeaarch64_sme_st1b_horiz><code>arm_sme.intr.st1b.horiz</code> (arm_sme::aarch64_sme_st1b_horiz)</a></li><li><a href=#arm_smeintrst1bvert-arm_smeaarch64_sme_st1b_vert><code>arm_sme.intr.st1b.vert</code> (arm_sme::aarch64_sme_st1b_vert)</a></li><li><a href=#arm_smeintrst1dhoriz-arm_smeaarch64_sme_st1d_horiz><code>arm_sme.intr.st1d.horiz</code> (arm_sme::aarch64_sme_st1d_horiz)</a></li><li><a href=#arm_smeintrst1dvert-arm_smeaarch64_sme_st1d_vert><code>arm_sme.intr.st1d.vert</code> (arm_sme::aarch64_sme_st1d_vert)</a></li><li><a href=#arm_smeintrst1hhoriz-arm_smeaarch64_sme_st1h_horiz><code>arm_sme.intr.st1h.horiz</code> (arm_sme::aarch64_sme_st1h_horiz)</a></li><li><a href=#arm_smeintrst1hvert-arm_smeaarch64_sme_st1h_vert><code>arm_sme.intr.st1h.vert</code> (arm_sme::aarch64_sme_st1h_vert)</a></li><li><a href=#arm_smeintrst1qhoriz-arm_smeaarch64_sme_st1q_horiz><code>arm_sme.intr.st1q.horiz</code> (arm_sme::aarch64_sme_st1q_horiz)</a></li><li><a href=#arm_smeintrst1qvert-arm_smeaarch64_sme_st1q_vert><code>arm_sme.intr.st1q.vert</code> (arm_sme::aarch64_sme_st1q_vert)</a></li><li><a href=#arm_smeintrst1whoriz-arm_smeaarch64_sme_st1w_horiz><code>arm_sme.intr.st1w.horiz</code> (arm_sme::aarch64_sme_st1w_horiz)</a></li><li><a href=#arm_smeintrst1wvert-arm_smeaarch64_sme_st1w_vert><code>arm_sme.intr.st1w.vert</code> (arm_sme::aarch64_sme_st1w_vert)</a></li><li><a href=#arm_smeintrstr-arm_smeaarch64_sme_str><code>arm_sme.intr.str</code> (arm_sme::aarch64_sme_str)</a></li><li><a href=#arm_smeintrsumopawide-arm_smeaarch64_sme_sumopa_wide><code>arm_sme.intr.sumopa.wide</code> (arm_sme::aarch64_sme_sumopa_wide)</a></li><li><a href=#arm_smeintrsumopswide-arm_smeaarch64_sme_sumops_wide><code>arm_sme.intr.sumops.wide</code> (arm_sme::aarch64_sme_sumops_wide)</a></li><li><a href=#arm_smeintrumopawide-arm_smeaarch64_sme_umopa_wide><code>arm_sme.intr.umopa.wide</code> (arm_sme::aarch64_sme_umopa_wide)</a></li><li><a href=#arm_smeintrumopswide-arm_smeaarch64_sme_umops_wide><code>arm_sme.intr.umops.wide</code> (arm_sme::aarch64_sme_umops_wide)</a></li><li><a href=#arm_smeintrusmopawide-arm_smeaarch64_sme_usmopa_wide><code>arm_sme.intr.usmopa.wide</code> (arm_sme::aarch64_sme_usmopa_wide)</a></li><li><a href=#arm_smeintrusmopswide-arm_smeaarch64_sme_usmops_wide><code>arm_sme.intr.usmops.wide</code> (arm_sme::aarch64_sme_usmops_wide)</a></li><li><a href=#arm_smeintrzadisable-arm_smeaarch64_sme_za_disable><code>arm_sme.intr.za.disable</code> (arm_sme::aarch64_sme_za_disable)</a></li><li><a href=#arm_smeintrzaenable-arm_smeaarch64_sme_za_enable><code>arm_sme.intr.za.enable</code> (arm_sme::aarch64_sme_za_enable)</a></li><li><a href=#arm_smeintrzero-arm_smeaarch64_sme_zero><code>arm_sme.intr.zero</code> (arm_sme::aarch64_sme_zero)</a></li><li><a href=#arm_smeload_tile_slice-arm_smeloadtilesliceop><code>arm_sme.load_tile_slice</code> (arm_sme::LoadTileSliceOp)</a></li><li><a href=#arm_smestore_tile_slice-arm_smestoretilesliceop><code>arm_sme.store_tile_slice</code> (arm_sme::StoreTileSliceOp)</a></li><li><a href=#arm_smetile_load-arm_smetileloadop><code>arm_sme.tile_load</code> (arm_sme::TileLoadOp)</a></li><li><a href=#arm_smetile_store-arm_smetilestoreop><code>arm_sme.tile_store</code> (arm_sme::TileStoreOp)</a></li><li><a href=#arm_smezero-arm_smezeroop><code>arm_sme.zero</code> (arm_sme::ZeroOp)</a></li></ul></li></ul></nav><h2 id=operation-definition>Operation definition&nbsp;<a class=headline-hash href=#operation-definition>¶</a></h2><h3 id=arm_smecast_tile_to_vector-arm_smecasttiletovector><code>arm_sme.cast_tile_to_vector</code> (arm_sme::CastTileToVector)&nbsp;<a class=headline-hash href=#arm_smecast_tile_to_vector-arm_smecasttiletovector>¶</a></h3><p><em>Cast from tile id to 2-d scalable vector type</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arm_sme.cast_tile_to_vector` $tile_id attr-dict `:` type($tile_id) `to` type($vector)
</code></pre><p>A <code>cast_tile_to_vector</code> operation does a cast from a tile id to a 2-d
scalable vector type, which represents an SME &ldquo;virtual tile&rdquo;. This would
normally be used when lowering operations that return &ldquo;virtual tile&rdquo; vector
types to model the output. This is required to preserve dataflow as SME
intrinsics have no return values.</p><p>Example:</p><p>Input:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%tile</span> <span class=p>=</span> <span class=kt>vector</span><span class=p>.</span>load <span class=nv>%mem1</span><span class=p>[</span><span class=nv>%c0</span><span class=p>]</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>i32</span><span class=p>&gt;,</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>4</span><span class=p>]x[</span><span class=m>4</span><span class=p>]</span>xi32<span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>vector</span><span class=p>.</span>store <span class=nv>%tile</span><span class=p>,</span> <span class=nv>%mem2</span><span class=p>[</span><span class=nv>%c0</span><span class=p>]</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>i32</span><span class=p>&gt;,</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>4</span><span class=p>]x[</span><span class=m>4</span><span class=p>]</span>xi32<span class=p>&gt;</span>
</span></span></code></pre></div><p>After lowering <code>vector.load</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%tile_id</span> <span class=p>=</span> arm_sme<span class=p>.</span>get_tile_id <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>scf<span class=p>.</span>for <span class=nv>%vnum</span> <span class=p>=</span> <span class=nv>%c0</span> to <span class=nv>%num_vectors</span> step <span class=nv>%c1</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c>// ...
</span></span></span><span class=line><span class=cl><span class=c></span>  <span class=s>&#34;arm_sme.intr.ld1w.horiz&#34;</span><span class=p>(</span><span class=nv>%pg</span><span class=p>,</span> <span class=nv>%ptr</span><span class=p>,</span> <span class=nv>%tile_id</span><span class=p>,</span> <span class=nv>%vnum</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=kt>vector</span><span class=p>&lt;[</span><span class=m>4</span><span class=p>]</span>xi1<span class=p>&gt;,</span> <span class=p>!</span>llvm<span class=p>.</span>ptr<span class=p>,</span> <span class=k>i32</span><span class=p>,</span> <span class=k>i32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nv>%tile</span> <span class=p>=</span> arm_sme<span class=p>.</span>cast_tile_to_vector <span class=nv>%tile_id</span> <span class=p>:</span> <span class=k>i32</span> to <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>4</span><span class=p>]x[</span><span class=m>4</span><span class=p>]</span>xi32<span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>vector</span><span class=p>.</span>store <span class=nv>%tile</span><span class=p>,</span> <span class=nv>%mem2</span><span class=p>[</span><span class=nv>%c0</span><span class=p>]</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>i32</span><span class=p>&gt;,</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>4</span><span class=p>]x[</span><span class=m>4</span><span class=p>]</span>xi32<span class=p>&gt;</span>
</span></span></code></pre></div><p>In the example above, the <code>vector.load</code> can&rsquo;t be replaced with an SME
intrinsic that has no outputs since it is used by the <code>vector.store</code>.
However, by inserting a <code>cast_tile_to_vector</code> op after the load intrinsics
the <code>vector.load</code> can be replaced. This enables &ldquo;local&rdquo; rewrites on
individual vector ops, rather than &ldquo;global&rdquo; rewrites that would have to
look at the vector op uses and also lower them.</p><p>Canonicalization will look through <code>arm_sme.cast_tile_to_vector</code> and fold
the cast away if it comes from a <code>arm_sme.cast_vector_to_tile</code>.</p><p>Traits: AlwaysSpeculatableImplTrait</p><p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands>Operands:&nbsp;<a class=headline-hash href=#operands>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>tile_id</code></td><td>8-bit signless integer or 16-bit signless integer or 32-bit signless integer or 64-bit signless integer or 128-bit signless integer</td></tr></tbody></table><h4 id=results>Results:&nbsp;<a class=headline-hash href=#results>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>vector</code></td><td>vector&lt;[16]x[16]xi8> of 8-bit signless integer values or vector&lt;[8]x[8]xi16> of 16-bit signless integer values or vector&lt;[4]x[4]xi32> of 32-bit signless integer values or vector&lt;[2]x[2]xi64> of 64-bit signless integer values or vector&lt;[1]x[1]xi128> of 128-bit signless integer values or vector&lt;[8]x[8]xf16> of 16-bit float values or vector&lt;[8]x[8]xbf16> of bfloat16 type values or vector&lt;[4]x[4]xf32> of 32-bit float values or vector&lt;[2]x[2]xf64> of 64-bit float values</td></tr></tbody></table><h3 id=arm_smecast_vector_to_tile-arm_smecastvectortotile><code>arm_sme.cast_vector_to_tile</code> (arm_sme::CastVectorToTile)&nbsp;<a class=headline-hash href=#arm_smecast_vector_to_tile-arm_smecastvectortotile>¶</a></h3><p><em>Cast from 2-d scalable vector type to tile id</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arm_sme.cast_vector_to_tile` $vector attr-dict `:` type($vector) `to` type($tile_id)
</code></pre><p>A <code>cast_vector_to_tile</code> operation does a cast from a 2-d scalable vector
type, which represents an SME &ldquo;virtual tile&rdquo;, to a tile id. This is
required to preserve dataflow as the SME intrinsics have no return values.</p><p>Example:</p><p>Input:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%tile</span> <span class=p>=</span> <span class=kt>vector</span><span class=p>.</span>load <span class=nv>%mem1</span><span class=p>[</span><span class=nv>%c0</span><span class=p>]</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>i32</span><span class=p>&gt;,</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>4</span><span class=p>]x[</span><span class=m>4</span><span class=p>]</span>xi32<span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>vector</span><span class=p>.</span>store <span class=nv>%tile</span><span class=p>,</span> <span class=nv>%mem2</span><span class=p>[</span><span class=nv>%c0</span><span class=p>]</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>i32</span><span class=p>&gt;,</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>4</span><span class=p>]x[</span><span class=m>4</span><span class=p>]</span>xi32<span class=p>&gt;</span>
</span></span></code></pre></div><p>After lowering <code>vector.store</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%tile</span> <span class=p>=</span> <span class=kt>vector</span><span class=p>.</span>load <span class=nv>%mem1</span><span class=p>[</span><span class=nv>%c0</span><span class=p>]</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>i32</span><span class=p>&gt;,</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>4</span><span class=p>]x[</span><span class=m>4</span><span class=p>]</span>xi32<span class=p>&gt;</span>
</span></span><span class=line><span class=cl>scf<span class=p>.</span>for <span class=nv>%vnum</span> <span class=p>=</span> <span class=nv>%c0</span> to <span class=nv>%num_vectors</span> step <span class=nv>%c1</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c>// ...
</span></span></span><span class=line><span class=cl><span class=c></span>  <span class=nv>%tile_id</span> <span class=p>=</span> arm_sme<span class=p>.</span>cast_vector_to_tile <span class=nv>%tile</span> <span class=p>:</span> <span class=p>(</span><span class=kt>vector</span><span class=p>&lt;[</span><span class=m>4</span><span class=p>]x[</span><span class=m>4</span><span class=p>]</span>xi32<span class=p>&gt;)</span> <span class=p>-&gt;</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>  <span class=s>&#34;arm_sme.intr.st1w.horiz&#34;</span><span class=p>(</span><span class=nv>%pg</span><span class=p>,</span> <span class=nv>%ptr</span><span class=p>,</span> <span class=nv>%tile_id</span><span class=p>,</span> <span class=nv>%vnum</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=kt>vector</span><span class=p>&lt;[</span><span class=m>4</span><span class=p>]</span>xi1<span class=p>&gt;,</span> <span class=p>!</span>llvm<span class=p>.</span>ptr<span class=p>,</span> <span class=k>i32</span><span class=p>,</span> <span class=k>i32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Canonicalization will look through <code>arm_sme.cast_vector_to_tile</code> and fold
the cast away if it comes from a <code>arm_sme.cast_tile_to_vector</code>.</p><p>Traits: AlwaysSpeculatableImplTrait</p><p>Interfaces: ConditionallySpeculatable, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-1>Operands:&nbsp;<a class=headline-hash href=#operands-1>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>vector</code></td><td>vector&lt;[16]x[16]xi8> of 8-bit signless integer values or vector&lt;[8]x[8]xi16> of 16-bit signless integer values or vector&lt;[4]x[4]xi32> of 32-bit signless integer values or vector&lt;[2]x[2]xi64> of 64-bit signless integer values or vector&lt;[1]x[1]xi128> of 128-bit signless integer values or vector&lt;[8]x[8]xf16> of 16-bit float values or vector&lt;[8]x[8]xbf16> of bfloat16 type values or vector&lt;[4]x[4]xf32> of 32-bit float values or vector&lt;[2]x[2]xf64> of 64-bit float values</td></tr></tbody></table><h4 id=results-1>Results:&nbsp;<a class=headline-hash href=#results-1>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>tile_id</code></td><td>8-bit signless integer or 16-bit signless integer or 32-bit signless integer or 64-bit signless integer or 128-bit signless integer</td></tr></tbody></table><h3 id=arm_smeget_tile_id-arm_smegettileid><code>arm_sme.get_tile_id</code> (arm_sme::GetTileID)&nbsp;<a class=headline-hash href=#arm_smeget_tile_id-arm_smegettileid>¶</a></h3><p><em>Returns an SME &ldquo;virtual tile&rdquo; id</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arm_sme.get_tile_id` attr-dict `:` type($tile_id)
</code></pre><p>A <code>get_tile_id</code> operation returns a scalar integer representing an SME
&ldquo;virtual tile&rdquo; id. The bitwidth of the scalar indicates the element
bitwidth of the &ldquo;virtual tile&rdquo;.</p><p>The scope of a tile id is a function and cannot be passed or returned from
functions.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Allocate and return an 8-bit element &#34;virtual tile&#34; id
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%za0_b</span> <span class=p>=</span> arm_sme<span class=p>.</span>get_tile_id <span class=p>:</span> <span class=k>i8</span>
</span></span></code></pre></div><p>Example:</p><pre tabindex=0><code>// Allocate and return two 16-bit element &#34;virtual tile&#34; ids
%za0_h = arm_sme.get_tile_id : i16
%za1_h = arm_sme.get_tile_id : i16
</code></pre><p>Example:</p><pre tabindex=0><code>// Allocate and return an 128-bit element &#34;virtual tile&#34; id
%za0_q = arm_sme.get_tile_id : i128
</code></pre><h4 id=results-2>Results:&nbsp;<a class=headline-hash href=#results-2>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>tile_id</code></td><td>8-bit signless integer or 16-bit signless integer or 32-bit signless integer or 64-bit signless integer or 128-bit signless integer</td></tr></tbody></table><h3 id=arm_smeintrld1bhoriz-arm_smeaarch64_sme_ld1b_horiz><code>arm_sme.intr.ld1b.horiz</code> (arm_sme::aarch64_sme_ld1b_horiz)&nbsp;<a class=headline-hash href=#arm_smeintrld1bhoriz-arm_smeaarch64_sme_ld1b_horiz>¶</a></h3><h4 id=operands-2>Operands:&nbsp;<a class=headline-hash href=#operands-2>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>scalable vector of 1-bit signless integer values of length 16/8/4/2/1</td></tr><tr><td style=text-align:center>«unnamed»</td><td>LLVM pointer type</td></tr><tr><td style=text-align:center>«unnamed»</td><td>32-bit signless integer</td></tr><tr><td style=text-align:center>«unnamed»</td><td>32-bit signless integer</td></tr></tbody></table><h3 id=arm_smeintrld1bvert-arm_smeaarch64_sme_ld1b_vert><code>arm_sme.intr.ld1b.vert</code> (arm_sme::aarch64_sme_ld1b_vert)&nbsp;<a class=headline-hash href=#arm_smeintrld1bvert-arm_smeaarch64_sme_ld1b_vert>¶</a></h3><h4 id=operands-3>Operands:&nbsp;<a class=headline-hash href=#operands-3>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>scalable vector of 1-bit signless integer values of length 16/8/4/2/1</td></tr><tr><td style=text-align:center>«unnamed»</td><td>LLVM pointer type</td></tr><tr><td style=text-align:center>«unnamed»</td><td>32-bit signless integer</td></tr><tr><td style=text-align:center>«unnamed»</td><td>32-bit signless integer</td></tr></tbody></table><h3 id=arm_smeintrld1dhoriz-arm_smeaarch64_sme_ld1d_horiz><code>arm_sme.intr.ld1d.horiz</code> (arm_sme::aarch64_sme_ld1d_horiz)&nbsp;<a class=headline-hash href=#arm_smeintrld1dhoriz-arm_smeaarch64_sme_ld1d_horiz>¶</a></h3><h4 id=operands-4>Operands:&nbsp;<a class=headline-hash href=#operands-4>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>scalable vector of 1-bit signless integer values of length 16/8/4/2/1</td></tr><tr><td style=text-align:center>«unnamed»</td><td>LLVM pointer type</td></tr><tr><td style=text-align:center>«unnamed»</td><td>32-bit signless integer</td></tr><tr><td style=text-align:center>«unnamed»</td><td>32-bit signless integer</td></tr></tbody></table><h3 id=arm_smeintrld1dvert-arm_smeaarch64_sme_ld1d_vert><code>arm_sme.intr.ld1d.vert</code> (arm_sme::aarch64_sme_ld1d_vert)&nbsp;<a class=headline-hash href=#arm_smeintrld1dvert-arm_smeaarch64_sme_ld1d_vert>¶</a></h3><h4 id=operands-5>Operands:&nbsp;<a class=headline-hash href=#operands-5>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>scalable vector of 1-bit signless integer values of length 16/8/4/2/1</td></tr><tr><td style=text-align:center>«unnamed»</td><td>LLVM pointer type</td></tr><tr><td style=text-align:center>«unnamed»</td><td>32-bit signless integer</td></tr><tr><td style=text-align:center>«unnamed»</td><td>32-bit signless integer</td></tr></tbody></table><h3 id=arm_smeintrld1hhoriz-arm_smeaarch64_sme_ld1h_horiz><code>arm_sme.intr.ld1h.horiz</code> (arm_sme::aarch64_sme_ld1h_horiz)&nbsp;<a class=headline-hash href=#arm_smeintrld1hhoriz-arm_smeaarch64_sme_ld1h_horiz>¶</a></h3><h4 id=operands-6>Operands:&nbsp;<a class=headline-hash href=#operands-6>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>scalable vector of 1-bit signless integer values of length 16/8/4/2/1</td></tr><tr><td style=text-align:center>«unnamed»</td><td>LLVM pointer type</td></tr><tr><td style=text-align:center>«unnamed»</td><td>32-bit signless integer</td></tr><tr><td style=text-align:center>«unnamed»</td><td>32-bit signless integer</td></tr></tbody></table><h3 id=arm_smeintrld1hvert-arm_smeaarch64_sme_ld1h_vert><code>arm_sme.intr.ld1h.vert</code> (arm_sme::aarch64_sme_ld1h_vert)&nbsp;<a class=headline-hash href=#arm_smeintrld1hvert-arm_smeaarch64_sme_ld1h_vert>¶</a></h3><h4 id=operands-7>Operands:&nbsp;<a class=headline-hash href=#operands-7>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>scalable vector of 1-bit signless integer values of length 16/8/4/2/1</td></tr><tr><td style=text-align:center>«unnamed»</td><td>LLVM pointer type</td></tr><tr><td style=text-align:center>«unnamed»</td><td>32-bit signless integer</td></tr><tr><td style=text-align:center>«unnamed»</td><td>32-bit signless integer</td></tr></tbody></table><h3 id=arm_smeintrld1qhoriz-arm_smeaarch64_sme_ld1q_horiz><code>arm_sme.intr.ld1q.horiz</code> (arm_sme::aarch64_sme_ld1q_horiz)&nbsp;<a class=headline-hash href=#arm_smeintrld1qhoriz-arm_smeaarch64_sme_ld1q_horiz>¶</a></h3><h4 id=operands-8>Operands:&nbsp;<a class=headline-hash href=#operands-8>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>scalable vector of 1-bit signless integer values of length 16/8/4/2/1</td></tr><tr><td style=text-align:center>«unnamed»</td><td>LLVM pointer type</td></tr><tr><td style=text-align:center>«unnamed»</td><td>32-bit signless integer</td></tr><tr><td style=text-align:center>«unnamed»</td><td>32-bit signless integer</td></tr></tbody></table><h3 id=arm_smeintrld1qvert-arm_smeaarch64_sme_ld1q_vert><code>arm_sme.intr.ld1q.vert</code> (arm_sme::aarch64_sme_ld1q_vert)&nbsp;<a class=headline-hash href=#arm_smeintrld1qvert-arm_smeaarch64_sme_ld1q_vert>¶</a></h3><h4 id=operands-9>Operands:&nbsp;<a class=headline-hash href=#operands-9>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>scalable vector of 1-bit signless integer values of length 16/8/4/2/1</td></tr><tr><td style=text-align:center>«unnamed»</td><td>LLVM pointer type</td></tr><tr><td style=text-align:center>«unnamed»</td><td>32-bit signless integer</td></tr><tr><td style=text-align:center>«unnamed»</td><td>32-bit signless integer</td></tr></tbody></table><h3 id=arm_smeintrld1whoriz-arm_smeaarch64_sme_ld1w_horiz><code>arm_sme.intr.ld1w.horiz</code> (arm_sme::aarch64_sme_ld1w_horiz)&nbsp;<a class=headline-hash href=#arm_smeintrld1whoriz-arm_smeaarch64_sme_ld1w_horiz>¶</a></h3><h4 id=operands-10>Operands:&nbsp;<a class=headline-hash href=#operands-10>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>scalable vector of 1-bit signless integer values of length 16/8/4/2/1</td></tr><tr><td style=text-align:center>«unnamed»</td><td>LLVM pointer type</td></tr><tr><td style=text-align:center>«unnamed»</td><td>32-bit signless integer</td></tr><tr><td style=text-align:center>«unnamed»</td><td>32-bit signless integer</td></tr></tbody></table><h3 id=arm_smeintrld1wvert-arm_smeaarch64_sme_ld1w_vert><code>arm_sme.intr.ld1w.vert</code> (arm_sme::aarch64_sme_ld1w_vert)&nbsp;<a class=headline-hash href=#arm_smeintrld1wvert-arm_smeaarch64_sme_ld1w_vert>¶</a></h3><h4 id=operands-11>Operands:&nbsp;<a class=headline-hash href=#operands-11>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>scalable vector of 1-bit signless integer values of length 16/8/4/2/1</td></tr><tr><td style=text-align:center>«unnamed»</td><td>LLVM pointer type</td></tr><tr><td style=text-align:center>«unnamed»</td><td>32-bit signless integer</td></tr><tr><td style=text-align:center>«unnamed»</td><td>32-bit signless integer</td></tr></tbody></table><h3 id=arm_smeintrmopa-arm_smeaarch64_sme_mopa><code>arm_sme.intr.mopa</code> (arm_sme::aarch64_sme_mopa)&nbsp;<a class=headline-hash href=#arm_smeintrmopa-arm_smeaarch64_sme_mopa>¶</a></h3><h4 id=operands-12>Operands:&nbsp;<a class=headline-hash href=#operands-12>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>32-bit signless integer</td></tr><tr><td style=text-align:center>«unnamed»</td><td>scalable vector of 1-bit signless integer values of length 16/8/4/2</td></tr><tr><td style=text-align:center>«unnamed»</td><td>scalable vector of 1-bit signless integer values of length 16/8/4/2</td></tr><tr><td style=text-align:center>«unnamed»</td><td>scalable vector of 8-bit signless integer or 16-bit signless integer or bfloat16 type or 16-bit float or 32-bit float or 64-bit float values of length 16/8/4/2</td></tr><tr><td style=text-align:center>«unnamed»</td><td>scalable vector of 8-bit signless integer or 16-bit signless integer or bfloat16 type or 16-bit float or 32-bit float or 64-bit float values of length 16/8/4/2</td></tr></tbody></table><h3 id=arm_smeintrmopawide-arm_smeaarch64_sme_mopa_wide><code>arm_sme.intr.mopa.wide</code> (arm_sme::aarch64_sme_mopa_wide)&nbsp;<a class=headline-hash href=#arm_smeintrmopawide-arm_smeaarch64_sme_mopa_wide>¶</a></h3><h4 id=operands-13>Operands:&nbsp;<a class=headline-hash href=#operands-13>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>32-bit signless integer</td></tr><tr><td style=text-align:center>«unnamed»</td><td>scalable vector of 1-bit signless integer values of length 16/8/4/2</td></tr><tr><td style=text-align:center>«unnamed»</td><td>scalable vector of 1-bit signless integer values of length 16/8/4/2</td></tr><tr><td style=text-align:center>«unnamed»</td><td>scalable vector of 8-bit signless integer or 16-bit signless integer or bfloat16 type or 16-bit float or 32-bit float or 64-bit float values of length 16/8/4/2</td></tr><tr><td style=text-align:center>«unnamed»</td><td>scalable vector of 8-bit signless integer or 16-bit signless integer or bfloat16 type or 16-bit float or 32-bit float or 64-bit float values of length 16/8/4/2</td></tr></tbody></table><h3 id=arm_smeintrmops-arm_smeaarch64_sme_mops><code>arm_sme.intr.mops</code> (arm_sme::aarch64_sme_mops)&nbsp;<a class=headline-hash href=#arm_smeintrmops-arm_smeaarch64_sme_mops>¶</a></h3><h4 id=operands-14>Operands:&nbsp;<a class=headline-hash href=#operands-14>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>32-bit signless integer</td></tr><tr><td style=text-align:center>«unnamed»</td><td>scalable vector of 1-bit signless integer values of length 16/8/4/2</td></tr><tr><td style=text-align:center>«unnamed»</td><td>scalable vector of 1-bit signless integer values of length 16/8/4/2</td></tr><tr><td style=text-align:center>«unnamed»</td><td>scalable vector of 8-bit signless integer or 16-bit signless integer or bfloat16 type or 16-bit float or 32-bit float or 64-bit float values of length 16/8/4/2</td></tr><tr><td style=text-align:center>«unnamed»</td><td>scalable vector of 8-bit signless integer or 16-bit signless integer or bfloat16 type or 16-bit float or 32-bit float or 64-bit float values of length 16/8/4/2</td></tr></tbody></table><h3 id=arm_smeintrmopswide-arm_smeaarch64_sme_mops_wide><code>arm_sme.intr.mops.wide</code> (arm_sme::aarch64_sme_mops_wide)&nbsp;<a class=headline-hash href=#arm_smeintrmopswide-arm_smeaarch64_sme_mops_wide>¶</a></h3><h4 id=operands-15>Operands:&nbsp;<a class=headline-hash href=#operands-15>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>32-bit signless integer</td></tr><tr><td style=text-align:center>«unnamed»</td><td>scalable vector of 1-bit signless integer values of length 16/8/4/2</td></tr><tr><td style=text-align:center>«unnamed»</td><td>scalable vector of 1-bit signless integer values of length 16/8/4/2</td></tr><tr><td style=text-align:center>«unnamed»</td><td>scalable vector of 8-bit signless integer or 16-bit signless integer or bfloat16 type or 16-bit float or 32-bit float or 64-bit float values of length 16/8/4/2</td></tr><tr><td style=text-align:center>«unnamed»</td><td>scalable vector of 8-bit signless integer or 16-bit signless integer or bfloat16 type or 16-bit float or 32-bit float or 64-bit float values of length 16/8/4/2</td></tr></tbody></table><h3 id=arm_smeintrsmopawide-arm_smeaarch64_sme_smopa_wide><code>arm_sme.intr.smopa.wide</code> (arm_sme::aarch64_sme_smopa_wide)&nbsp;<a class=headline-hash href=#arm_smeintrsmopawide-arm_smeaarch64_sme_smopa_wide>¶</a></h3><h4 id=operands-16>Operands:&nbsp;<a class=headline-hash href=#operands-16>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>32-bit signless integer</td></tr><tr><td style=text-align:center>«unnamed»</td><td>scalable vector of 1-bit signless integer values of length 16/8/4/2</td></tr><tr><td style=text-align:center>«unnamed»</td><td>scalable vector of 1-bit signless integer values of length 16/8/4/2</td></tr><tr><td style=text-align:center>«unnamed»</td><td>scalable vector of 8-bit signless integer or 16-bit signless integer or bfloat16 type or 16-bit float or 32-bit float or 64-bit float values of length 16/8/4/2</td></tr><tr><td style=text-align:center>«unnamed»</td><td>scalable vector of 8-bit signless integer or 16-bit signless integer or bfloat16 type or 16-bit float or 32-bit float or 64-bit float values of length 16/8/4/2</td></tr></tbody></table><h3 id=arm_smeintrsmopswide-arm_smeaarch64_sme_smops_wide><code>arm_sme.intr.smops.wide</code> (arm_sme::aarch64_sme_smops_wide)&nbsp;<a class=headline-hash href=#arm_smeintrsmopswide-arm_smeaarch64_sme_smops_wide>¶</a></h3><h4 id=operands-17>Operands:&nbsp;<a class=headline-hash href=#operands-17>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>32-bit signless integer</td></tr><tr><td style=text-align:center>«unnamed»</td><td>scalable vector of 1-bit signless integer values of length 16/8/4/2</td></tr><tr><td style=text-align:center>«unnamed»</td><td>scalable vector of 1-bit signless integer values of length 16/8/4/2</td></tr><tr><td style=text-align:center>«unnamed»</td><td>scalable vector of 8-bit signless integer or 16-bit signless integer or bfloat16 type or 16-bit float or 32-bit float or 64-bit float values of length 16/8/4/2</td></tr><tr><td style=text-align:center>«unnamed»</td><td>scalable vector of 8-bit signless integer or 16-bit signless integer or bfloat16 type or 16-bit float or 32-bit float or 64-bit float values of length 16/8/4/2</td></tr></tbody></table><h3 id=arm_smeintrst1bhoriz-arm_smeaarch64_sme_st1b_horiz><code>arm_sme.intr.st1b.horiz</code> (arm_sme::aarch64_sme_st1b_horiz)&nbsp;<a class=headline-hash href=#arm_smeintrst1bhoriz-arm_smeaarch64_sme_st1b_horiz>¶</a></h3><h4 id=operands-18>Operands:&nbsp;<a class=headline-hash href=#operands-18>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>scalable vector of 1-bit signless integer values of length 16/8/4/2/1</td></tr><tr><td style=text-align:center>«unnamed»</td><td>LLVM pointer type</td></tr><tr><td style=text-align:center>«unnamed»</td><td>32-bit signless integer</td></tr><tr><td style=text-align:center>«unnamed»</td><td>32-bit signless integer</td></tr></tbody></table><h3 id=arm_smeintrst1bvert-arm_smeaarch64_sme_st1b_vert><code>arm_sme.intr.st1b.vert</code> (arm_sme::aarch64_sme_st1b_vert)&nbsp;<a class=headline-hash href=#arm_smeintrst1bvert-arm_smeaarch64_sme_st1b_vert>¶</a></h3><h4 id=operands-19>Operands:&nbsp;<a class=headline-hash href=#operands-19>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>scalable vector of 1-bit signless integer values of length 16/8/4/2/1</td></tr><tr><td style=text-align:center>«unnamed»</td><td>LLVM pointer type</td></tr><tr><td style=text-align:center>«unnamed»</td><td>32-bit signless integer</td></tr><tr><td style=text-align:center>«unnamed»</td><td>32-bit signless integer</td></tr></tbody></table><h3 id=arm_smeintrst1dhoriz-arm_smeaarch64_sme_st1d_horiz><code>arm_sme.intr.st1d.horiz</code> (arm_sme::aarch64_sme_st1d_horiz)&nbsp;<a class=headline-hash href=#arm_smeintrst1dhoriz-arm_smeaarch64_sme_st1d_horiz>¶</a></h3><h4 id=operands-20>Operands:&nbsp;<a class=headline-hash href=#operands-20>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>scalable vector of 1-bit signless integer values of length 16/8/4/2/1</td></tr><tr><td style=text-align:center>«unnamed»</td><td>LLVM pointer type</td></tr><tr><td style=text-align:center>«unnamed»</td><td>32-bit signless integer</td></tr><tr><td style=text-align:center>«unnamed»</td><td>32-bit signless integer</td></tr></tbody></table><h3 id=arm_smeintrst1dvert-arm_smeaarch64_sme_st1d_vert><code>arm_sme.intr.st1d.vert</code> (arm_sme::aarch64_sme_st1d_vert)&nbsp;<a class=headline-hash href=#arm_smeintrst1dvert-arm_smeaarch64_sme_st1d_vert>¶</a></h3><h4 id=operands-21>Operands:&nbsp;<a class=headline-hash href=#operands-21>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>scalable vector of 1-bit signless integer values of length 16/8/4/2/1</td></tr><tr><td style=text-align:center>«unnamed»</td><td>LLVM pointer type</td></tr><tr><td style=text-align:center>«unnamed»</td><td>32-bit signless integer</td></tr><tr><td style=text-align:center>«unnamed»</td><td>32-bit signless integer</td></tr></tbody></table><h3 id=arm_smeintrst1hhoriz-arm_smeaarch64_sme_st1h_horiz><code>arm_sme.intr.st1h.horiz</code> (arm_sme::aarch64_sme_st1h_horiz)&nbsp;<a class=headline-hash href=#arm_smeintrst1hhoriz-arm_smeaarch64_sme_st1h_horiz>¶</a></h3><h4 id=operands-22>Operands:&nbsp;<a class=headline-hash href=#operands-22>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>scalable vector of 1-bit signless integer values of length 16/8/4/2/1</td></tr><tr><td style=text-align:center>«unnamed»</td><td>LLVM pointer type</td></tr><tr><td style=text-align:center>«unnamed»</td><td>32-bit signless integer</td></tr><tr><td style=text-align:center>«unnamed»</td><td>32-bit signless integer</td></tr></tbody></table><h3 id=arm_smeintrst1hvert-arm_smeaarch64_sme_st1h_vert><code>arm_sme.intr.st1h.vert</code> (arm_sme::aarch64_sme_st1h_vert)&nbsp;<a class=headline-hash href=#arm_smeintrst1hvert-arm_smeaarch64_sme_st1h_vert>¶</a></h3><h4 id=operands-23>Operands:&nbsp;<a class=headline-hash href=#operands-23>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>scalable vector of 1-bit signless integer values of length 16/8/4/2/1</td></tr><tr><td style=text-align:center>«unnamed»</td><td>LLVM pointer type</td></tr><tr><td style=text-align:center>«unnamed»</td><td>32-bit signless integer</td></tr><tr><td style=text-align:center>«unnamed»</td><td>32-bit signless integer</td></tr></tbody></table><h3 id=arm_smeintrst1qhoriz-arm_smeaarch64_sme_st1q_horiz><code>arm_sme.intr.st1q.horiz</code> (arm_sme::aarch64_sme_st1q_horiz)&nbsp;<a class=headline-hash href=#arm_smeintrst1qhoriz-arm_smeaarch64_sme_st1q_horiz>¶</a></h3><h4 id=operands-24>Operands:&nbsp;<a class=headline-hash href=#operands-24>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>scalable vector of 1-bit signless integer values of length 16/8/4/2/1</td></tr><tr><td style=text-align:center>«unnamed»</td><td>LLVM pointer type</td></tr><tr><td style=text-align:center>«unnamed»</td><td>32-bit signless integer</td></tr><tr><td style=text-align:center>«unnamed»</td><td>32-bit signless integer</td></tr></tbody></table><h3 id=arm_smeintrst1qvert-arm_smeaarch64_sme_st1q_vert><code>arm_sme.intr.st1q.vert</code> (arm_sme::aarch64_sme_st1q_vert)&nbsp;<a class=headline-hash href=#arm_smeintrst1qvert-arm_smeaarch64_sme_st1q_vert>¶</a></h3><h4 id=operands-25>Operands:&nbsp;<a class=headline-hash href=#operands-25>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>scalable vector of 1-bit signless integer values of length 16/8/4/2/1</td></tr><tr><td style=text-align:center>«unnamed»</td><td>LLVM pointer type</td></tr><tr><td style=text-align:center>«unnamed»</td><td>32-bit signless integer</td></tr><tr><td style=text-align:center>«unnamed»</td><td>32-bit signless integer</td></tr></tbody></table><h3 id=arm_smeintrst1whoriz-arm_smeaarch64_sme_st1w_horiz><code>arm_sme.intr.st1w.horiz</code> (arm_sme::aarch64_sme_st1w_horiz)&nbsp;<a class=headline-hash href=#arm_smeintrst1whoriz-arm_smeaarch64_sme_st1w_horiz>¶</a></h3><h4 id=operands-26>Operands:&nbsp;<a class=headline-hash href=#operands-26>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>scalable vector of 1-bit signless integer values of length 16/8/4/2/1</td></tr><tr><td style=text-align:center>«unnamed»</td><td>LLVM pointer type</td></tr><tr><td style=text-align:center>«unnamed»</td><td>32-bit signless integer</td></tr><tr><td style=text-align:center>«unnamed»</td><td>32-bit signless integer</td></tr></tbody></table><h3 id=arm_smeintrst1wvert-arm_smeaarch64_sme_st1w_vert><code>arm_sme.intr.st1w.vert</code> (arm_sme::aarch64_sme_st1w_vert)&nbsp;<a class=headline-hash href=#arm_smeintrst1wvert-arm_smeaarch64_sme_st1w_vert>¶</a></h3><h4 id=operands-27>Operands:&nbsp;<a class=headline-hash href=#operands-27>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>scalable vector of 1-bit signless integer values of length 16/8/4/2/1</td></tr><tr><td style=text-align:center>«unnamed»</td><td>LLVM pointer type</td></tr><tr><td style=text-align:center>«unnamed»</td><td>32-bit signless integer</td></tr><tr><td style=text-align:center>«unnamed»</td><td>32-bit signless integer</td></tr></tbody></table><h3 id=arm_smeintrstr-arm_smeaarch64_sme_str><code>arm_sme.intr.str</code> (arm_sme::aarch64_sme_str)&nbsp;<a class=headline-hash href=#arm_smeintrstr-arm_smeaarch64_sme_str>¶</a></h3><h4 id=operands-28>Operands:&nbsp;<a class=headline-hash href=#operands-28>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>32-bit signless integer</td></tr><tr><td style=text-align:center>«unnamed»</td><td>LLVM pointer type</td></tr></tbody></table><h3 id=arm_smeintrsumopawide-arm_smeaarch64_sme_sumopa_wide><code>arm_sme.intr.sumopa.wide</code> (arm_sme::aarch64_sme_sumopa_wide)&nbsp;<a class=headline-hash href=#arm_smeintrsumopawide-arm_smeaarch64_sme_sumopa_wide>¶</a></h3><h4 id=operands-29>Operands:&nbsp;<a class=headline-hash href=#operands-29>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>32-bit signless integer</td></tr><tr><td style=text-align:center>«unnamed»</td><td>scalable vector of 1-bit signless integer values of length 16/8/4/2</td></tr><tr><td style=text-align:center>«unnamed»</td><td>scalable vector of 1-bit signless integer values of length 16/8/4/2</td></tr><tr><td style=text-align:center>«unnamed»</td><td>scalable vector of 8-bit signless integer or 16-bit signless integer or bfloat16 type or 16-bit float or 32-bit float or 64-bit float values of length 16/8/4/2</td></tr><tr><td style=text-align:center>«unnamed»</td><td>scalable vector of 8-bit signless integer or 16-bit signless integer or bfloat16 type or 16-bit float or 32-bit float or 64-bit float values of length 16/8/4/2</td></tr></tbody></table><h3 id=arm_smeintrsumopswide-arm_smeaarch64_sme_sumops_wide><code>arm_sme.intr.sumops.wide</code> (arm_sme::aarch64_sme_sumops_wide)&nbsp;<a class=headline-hash href=#arm_smeintrsumopswide-arm_smeaarch64_sme_sumops_wide>¶</a></h3><h4 id=operands-30>Operands:&nbsp;<a class=headline-hash href=#operands-30>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>32-bit signless integer</td></tr><tr><td style=text-align:center>«unnamed»</td><td>scalable vector of 1-bit signless integer values of length 16/8/4/2</td></tr><tr><td style=text-align:center>«unnamed»</td><td>scalable vector of 1-bit signless integer values of length 16/8/4/2</td></tr><tr><td style=text-align:center>«unnamed»</td><td>scalable vector of 8-bit signless integer or 16-bit signless integer or bfloat16 type or 16-bit float or 32-bit float or 64-bit float values of length 16/8/4/2</td></tr><tr><td style=text-align:center>«unnamed»</td><td>scalable vector of 8-bit signless integer or 16-bit signless integer or bfloat16 type or 16-bit float or 32-bit float or 64-bit float values of length 16/8/4/2</td></tr></tbody></table><h3 id=arm_smeintrumopawide-arm_smeaarch64_sme_umopa_wide><code>arm_sme.intr.umopa.wide</code> (arm_sme::aarch64_sme_umopa_wide)&nbsp;<a class=headline-hash href=#arm_smeintrumopawide-arm_smeaarch64_sme_umopa_wide>¶</a></h3><h4 id=operands-31>Operands:&nbsp;<a class=headline-hash href=#operands-31>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>32-bit signless integer</td></tr><tr><td style=text-align:center>«unnamed»</td><td>scalable vector of 1-bit signless integer values of length 16/8/4/2</td></tr><tr><td style=text-align:center>«unnamed»</td><td>scalable vector of 1-bit signless integer values of length 16/8/4/2</td></tr><tr><td style=text-align:center>«unnamed»</td><td>scalable vector of 8-bit signless integer or 16-bit signless integer or bfloat16 type or 16-bit float or 32-bit float or 64-bit float values of length 16/8/4/2</td></tr><tr><td style=text-align:center>«unnamed»</td><td>scalable vector of 8-bit signless integer or 16-bit signless integer or bfloat16 type or 16-bit float or 32-bit float or 64-bit float values of length 16/8/4/2</td></tr></tbody></table><h3 id=arm_smeintrumopswide-arm_smeaarch64_sme_umops_wide><code>arm_sme.intr.umops.wide</code> (arm_sme::aarch64_sme_umops_wide)&nbsp;<a class=headline-hash href=#arm_smeintrumopswide-arm_smeaarch64_sme_umops_wide>¶</a></h3><h4 id=operands-32>Operands:&nbsp;<a class=headline-hash href=#operands-32>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>32-bit signless integer</td></tr><tr><td style=text-align:center>«unnamed»</td><td>scalable vector of 1-bit signless integer values of length 16/8/4/2</td></tr><tr><td style=text-align:center>«unnamed»</td><td>scalable vector of 1-bit signless integer values of length 16/8/4/2</td></tr><tr><td style=text-align:center>«unnamed»</td><td>scalable vector of 8-bit signless integer or 16-bit signless integer or bfloat16 type or 16-bit float or 32-bit float or 64-bit float values of length 16/8/4/2</td></tr><tr><td style=text-align:center>«unnamed»</td><td>scalable vector of 8-bit signless integer or 16-bit signless integer or bfloat16 type or 16-bit float or 32-bit float or 64-bit float values of length 16/8/4/2</td></tr></tbody></table><h3 id=arm_smeintrusmopawide-arm_smeaarch64_sme_usmopa_wide><code>arm_sme.intr.usmopa.wide</code> (arm_sme::aarch64_sme_usmopa_wide)&nbsp;<a class=headline-hash href=#arm_smeintrusmopawide-arm_smeaarch64_sme_usmopa_wide>¶</a></h3><h4 id=operands-33>Operands:&nbsp;<a class=headline-hash href=#operands-33>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>32-bit signless integer</td></tr><tr><td style=text-align:center>«unnamed»</td><td>scalable vector of 1-bit signless integer values of length 16/8/4/2</td></tr><tr><td style=text-align:center>«unnamed»</td><td>scalable vector of 1-bit signless integer values of length 16/8/4/2</td></tr><tr><td style=text-align:center>«unnamed»</td><td>scalable vector of 8-bit signless integer or 16-bit signless integer or bfloat16 type or 16-bit float or 32-bit float or 64-bit float values of length 16/8/4/2</td></tr><tr><td style=text-align:center>«unnamed»</td><td>scalable vector of 8-bit signless integer or 16-bit signless integer or bfloat16 type or 16-bit float or 32-bit float or 64-bit float values of length 16/8/4/2</td></tr></tbody></table><h3 id=arm_smeintrusmopswide-arm_smeaarch64_sme_usmops_wide><code>arm_sme.intr.usmops.wide</code> (arm_sme::aarch64_sme_usmops_wide)&nbsp;<a class=headline-hash href=#arm_smeintrusmopswide-arm_smeaarch64_sme_usmops_wide>¶</a></h3><h4 id=operands-34>Operands:&nbsp;<a class=headline-hash href=#operands-34>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>32-bit signless integer</td></tr><tr><td style=text-align:center>«unnamed»</td><td>scalable vector of 1-bit signless integer values of length 16/8/4/2</td></tr><tr><td style=text-align:center>«unnamed»</td><td>scalable vector of 1-bit signless integer values of length 16/8/4/2</td></tr><tr><td style=text-align:center>«unnamed»</td><td>scalable vector of 8-bit signless integer or 16-bit signless integer or bfloat16 type or 16-bit float or 32-bit float or 64-bit float values of length 16/8/4/2</td></tr><tr><td style=text-align:center>«unnamed»</td><td>scalable vector of 8-bit signless integer or 16-bit signless integer or bfloat16 type or 16-bit float or 32-bit float or 64-bit float values of length 16/8/4/2</td></tr></tbody></table><h3 id=arm_smeintrzadisable-arm_smeaarch64_sme_za_disable><code>arm_sme.intr.za.disable</code> (arm_sme::aarch64_sme_za_disable)&nbsp;<a class=headline-hash href=#arm_smeintrzadisable-arm_smeaarch64_sme_za_disable>¶</a></h3><h3 id=arm_smeintrzaenable-arm_smeaarch64_sme_za_enable><code>arm_sme.intr.za.enable</code> (arm_sme::aarch64_sme_za_enable)&nbsp;<a class=headline-hash href=#arm_smeintrzaenable-arm_smeaarch64_sme_za_enable>¶</a></h3><h3 id=arm_smeintrzero-arm_smeaarch64_sme_zero><code>arm_sme.intr.zero</code> (arm_sme::aarch64_sme_zero)&nbsp;<a class=headline-hash href=#arm_smeintrzero-arm_smeaarch64_sme_zero>¶</a></h3><h4 id=operands-35>Operands:&nbsp;<a class=headline-hash href=#operands-35>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>32-bit signless integer</td></tr></tbody></table><h3 id=arm_smeload_tile_slice-arm_smeloadtilesliceop><code>arm_sme.load_tile_slice</code> (arm_sme::LoadTileSliceOp)&nbsp;<a class=headline-hash href=#arm_smeload_tile_slice-arm_smeloadtilesliceop>¶</a></h3><p><em>Tile slice load and update operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arm_sme.load_tile_slice` $base `[` $indices `]` `,` $tile `,` $tile_slice_index
              attr-dict `:` type($base) `,` type($result)
</code></pre><p>Loads a 1D tile slice from memory into a 2D SME &ldquo;virtual tile&rdquo;. The tile
slice is defined by the dimension of the 2D scalable vector type pointed by
the index. A tile slice index describes where in the input tile the tile
slice is loaded to. The updated tile is returned as the result.</p><p>The slice of memory read is defined by a base and indices and must be
contiguous. The memref must be either rank 1 or rank 2, have dynamic
dimensions since the operation is scalable, and the element type must be a
scalar that matches the element type of the result.</p><p>Example 1: Load a vector&lt;[16]xi8> tile slice from memory into tile at given index.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%tile_update</span> <span class=p>=</span> arm_sme<span class=p>.</span>load_tile_slice <span class=nv>%base</span><span class=p>[</span><span class=nv>%c0</span><span class=p>],</span> <span class=nv>%tile</span><span class=p>,</span> <span class=nv>%tile_slice_index</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>i8</span><span class=p>&gt;,</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>16</span><span class=p>]x[</span><span class=m>16</span><span class=p>]</span>xi8<span class=p>&gt;</span>
</span></span></code></pre></div><p>Example 2: Load a vector&lt;[4]xf32> tile slice from memory into tile at given index.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%tile_update</span> <span class=p>=</span> arm_sme<span class=p>.</span>load_tile_slice <span class=nv>%base</span><span class=p>[</span><span class=nv>%c0</span><span class=p>],</span> <span class=nv>%tile</span><span class=p>,</span> <span class=nv>%tile_slice_index</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>&gt;,</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>4</span><span class=p>]x[</span><span class=m>4</span><span class=p>]</span>xf32<span class=p>&gt;</span>
</span></span></code></pre></div><p>Example 3: Load a vector&lt;[1]xi128> tile slice from memory into tile at given index.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%tile_update</span> <span class=p>=</span> arm_sme<span class=p>.</span>load_tile_slice <span class=nv>%base</span><span class=p>[</span><span class=nv>%c0</span><span class=p>],</span> <span class=nv>%tile</span><span class=p>,</span> <span class=nv>%tile_slice_index</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>i128</span><span class=p>&gt;,</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>1</span><span class=p>]x[</span><span class=m>1</span><span class=p>]</span>xi128<span class=p>&gt;</span>
</span></span></code></pre></div><p>Interfaces: InferTypeOpInterface</p><h4 id=operands-36>Operands:&nbsp;<a class=headline-hash href=#operands-36>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>base</code></td><td>memref of any type values</td></tr><tr><td style=text-align:center><code>tile</code></td><td>vector&lt;[16]x[16]xi8> of 8-bit signless integer values or vector&lt;[8]x[8]xi16> of 16-bit signless integer values or vector&lt;[4]x[4]xi32> of 32-bit signless integer values or vector&lt;[2]x[2]xi64> of 64-bit signless integer values or vector&lt;[1]x[1]xi128> of 128-bit signless integer values or vector&lt;[8]x[8]xf16> of 16-bit float values or vector&lt;[8]x[8]xbf16> of bfloat16 type values or vector&lt;[4]x[4]xf32> of 32-bit float values or vector&lt;[2]x[2]xf64> of 64-bit float values</td></tr><tr><td style=text-align:center><code>indices</code></td><td>index</td></tr><tr><td style=text-align:center><code>tile_slice_index</code></td><td>index</td></tr></tbody></table><h4 id=results-3>Results:&nbsp;<a class=headline-hash href=#results-3>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>vector&lt;[16]x[16]xi8> of 8-bit signless integer values or vector&lt;[8]x[8]xi16> of 16-bit signless integer values or vector&lt;[4]x[4]xi32> of 32-bit signless integer values or vector&lt;[2]x[2]xi64> of 64-bit signless integer values or vector&lt;[1]x[1]xi128> of 128-bit signless integer values or vector&lt;[8]x[8]xf16> of 16-bit float values or vector&lt;[8]x[8]xbf16> of bfloat16 type values or vector&lt;[4]x[4]xf32> of 32-bit float values or vector&lt;[2]x[2]xf64> of 64-bit float values</td></tr></tbody></table><h3 id=arm_smestore_tile_slice-arm_smestoretilesliceop><code>arm_sme.store_tile_slice</code> (arm_sme::StoreTileSliceOp)&nbsp;<a class=headline-hash href=#arm_smestore_tile_slice-arm_smestoretilesliceop>¶</a></h3><p><em>Tile slice store operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arm_sme.store_tile_slice` $tile `,` $tile_slice_index `,` $base `[` $indices `]`
              attr-dict `:` type($base) `,` type($tile)
</code></pre><p>Stores a 1D tile slice from a 2D SME &ldquo;virtual tile&rdquo; into memory. The tile
slice is defined by the dimension of the 2D scalable vector type pointed by
the index. A tile slice index describes where in the input tile the tile
slice is stored from.</p><p>The slice of memory written is defined by a base and indices and must be
contiguous. The memref must be either rank 1 or rank 2, have dynamic
dimensions since the operation is scalable, and the element type must be a
scalar that matches the element type of the input tile.</p><p>Example 1: Store vector&lt;[16]xi8> tile slice from tile at given index to memory.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>arm_sme<span class=p>.</span>store_tile_slice <span class=nv>%tile</span><span class=p>,</span> <span class=nv>%tile_slice_index</span><span class=p>,</span> <span class=nv>%base</span><span class=p>[</span><span class=nv>%c0</span><span class=p>]</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>16</span><span class=p>]x[</span><span class=m>16</span><span class=p>]</span>xi8<span class=p>&gt;,</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>i8</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Example 2: Store vector&lt;[4]xf32> tile slice from tile at given index to memory.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>arm_sme<span class=p>.</span>store_tile_slice <span class=nv>%tile</span><span class=p>,</span> <span class=nv>%tile_slice_index</span><span class=p>,</span> <span class=nv>%base</span><span class=p>[</span><span class=nv>%c0</span><span class=p>]</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>4</span><span class=p>]x[</span><span class=m>4</span><span class=p>]</span>xf32<span class=p>&gt;,</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Example 3: Store a vector&lt;[1]xi128> tile slice from tile at given index to memory.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>arm_sme<span class=p>.</span>store_tile_slice <span class=nv>%tile</span><span class=p>,</span> <span class=nv>%tile_slice_index</span><span class=p>,</span> <span class=nv>%base</span><span class=p>[</span><span class=nv>%c0</span><span class=p>]</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>1</span><span class=p>]x[</span><span class=m>1</span><span class=p>]</span>xi128<span class=p>&gt;,</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>i128</span><span class=p>&gt;</span>
</span></span></code></pre></div><h4 id=operands-37>Operands:&nbsp;<a class=headline-hash href=#operands-37>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>tile</code></td><td>vector&lt;[16]x[16]xi8> of 8-bit signless integer values or vector&lt;[8]x[8]xi16> of 16-bit signless integer values or vector&lt;[4]x[4]xi32> of 32-bit signless integer values or vector&lt;[2]x[2]xi64> of 64-bit signless integer values or vector&lt;[1]x[1]xi128> of 128-bit signless integer values or vector&lt;[8]x[8]xf16> of 16-bit float values or vector&lt;[8]x[8]xbf16> of bfloat16 type values or vector&lt;[4]x[4]xf32> of 32-bit float values or vector&lt;[2]x[2]xf64> of 64-bit float values</td></tr><tr><td style=text-align:center><code>tile_slice_index</code></td><td>index</td></tr><tr><td style=text-align:center><code>base</code></td><td>memref of any type values</td></tr><tr><td style=text-align:center><code>indices</code></td><td>index</td></tr></tbody></table><h3 id=arm_smetile_load-arm_smetileloadop><code>arm_sme.tile_load</code> (arm_sme::TileLoadOp)&nbsp;<a class=headline-hash href=#arm_smetile_load-arm_smetileloadop>¶</a></h3><p><em>Tile load operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arm_sme.tile_load` $base `[` $indices `]` attr-dict `:` type($base) `,` type($result)
</code></pre><p>Loads a 2D SME &ldquo;virtual tile&rdquo; from memory defined by a base and indices,
with the shape defined by the 2D scalable vector type of the result tile.
The slice of memory must be contiguous. The memref must be either rank 1 or
rank 2 with dynamic dimensions, since the operation is scalable, and the
element type must be a scalar that matches the element type of the result.</p><p>Example 1: Load an 8-bit element ZA tile from memory (ZA0.B).</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%tile</span> <span class=p>=</span> arm_sme<span class=p>.</span>tile_load <span class=nv>%base</span><span class=p>[</span><span class=nv>%c0</span><span class=p>,</span> <span class=nv>%c0</span><span class=p>]</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>i8</span><span class=p>&gt;,</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>16</span><span class=p>]x[</span><span class=m>16</span><span class=p>]</span>xi8<span class=p>&gt;</span>
</span></span></code></pre></div><p>Example 2: Load a FP 32-bit element ZA tile from memory.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%tile</span> <span class=p>=</span> arm_sme<span class=p>.</span>tile_load <span class=nv>%base</span><span class=p>[</span><span class=nv>%c0</span><span class=p>,</span> <span class=nv>%c0</span><span class=p>]</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>&gt;,</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>4</span><span class=p>]x[</span><span class=m>4</span><span class=p>]</span>xf32<span class=p>&gt;</span>
</span></span></code></pre></div><p>Example 3: Load a 128-bit element ZA tile from memory.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%tile</span> <span class=p>=</span> arm_sme<span class=p>.</span>tile_load <span class=nv>%base</span><span class=p>[</span><span class=nv>%c0</span><span class=p>,</span> <span class=nv>%c0</span><span class=p>]</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>i128</span><span class=p>&gt;,</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>1</span><span class=p>]x[</span><span class=m>1</span><span class=p>]</span>xi128<span class=p>&gt;</span>
</span></span></code></pre></div><h4 id=operands-38>Operands:&nbsp;<a class=headline-hash href=#operands-38>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>base</code></td><td>memref of any type values</td></tr><tr><td style=text-align:center><code>indices</code></td><td>index</td></tr></tbody></table><h4 id=results-4>Results:&nbsp;<a class=headline-hash href=#results-4>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>vector&lt;[16]x[16]xi8> of 8-bit signless integer values or vector&lt;[8]x[8]xi16> of 16-bit signless integer values or vector&lt;[4]x[4]xi32> of 32-bit signless integer values or vector&lt;[2]x[2]xi64> of 64-bit signless integer values or vector&lt;[1]x[1]xi128> of 128-bit signless integer values or vector&lt;[8]x[8]xf16> of 16-bit float values or vector&lt;[8]x[8]xbf16> of bfloat16 type values or vector&lt;[4]x[4]xf32> of 32-bit float values or vector&lt;[2]x[2]xf64> of 64-bit float values</td></tr></tbody></table><h3 id=arm_smetile_store-arm_smetilestoreop><code>arm_sme.tile_store</code> (arm_sme::TileStoreOp)&nbsp;<a class=headline-hash href=#arm_smetile_store-arm_smetilestoreop>¶</a></h3><p><em>Tile store operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arm_sme.tile_store` $valueToStore `,` $base `[` $indices `]` attr-dict `:` type($base) `,` type($valueToStore)
</code></pre><p>Stores a 2D SME &ldquo;virtual tile&rdquo; to memory defined by a base and indices,
with the shape defined by the 2D scalable vector type of the tile being
stored. The slice of memory must be contiguous. The memref must be either
rank 1 or rank 2 with dynamic dimensions, since the operation is scalable,
and the element type must be a scalar that matches the element type of the
result.</p><p>Example 1: Store an 8-bit element ZA tile to memory (ZA0.B).</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>arm_sme<span class=p>.</span>tile_store <span class=nv>%tile</span><span class=p>,</span> <span class=nv>%base</span><span class=p>[</span><span class=nv>%c0</span><span class=p>,</span> <span class=nv>%c0</span><span class=p>]</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>16</span><span class=p>]x[</span><span class=m>16</span><span class=p>]</span>xi8<span class=p>&gt;,</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>i8</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Example 2: Store a FP 32-bit element ZA tile to memory.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>arm_sme<span class=p>.</span>tile_store <span class=nv>%tile</span><span class=p>,</span> <span class=nv>%base</span><span class=p>[</span><span class=nv>%c0</span><span class=p>,</span> <span class=nv>%c0</span><span class=p>]</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>4</span><span class=p>]x[</span><span class=m>4</span><span class=p>]</span>xf32<span class=p>&gt;,</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Example 3: Store a 128-bit element ZA tile to memory.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>arm_sme<span class=p>.</span>tile_store <span class=nv>%tile</span><span class=p>,</span> <span class=nv>%base</span><span class=p>[</span><span class=nv>%c0</span><span class=p>,</span> <span class=nv>%c0</span><span class=p>]</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>1</span><span class=p>]x[</span><span class=m>1</span><span class=p>]</span>xi128<span class=p>&gt;,</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>i128</span><span class=p>&gt;</span>
</span></span></code></pre></div><h4 id=operands-39>Operands:&nbsp;<a class=headline-hash href=#operands-39>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>valueToStore</code></td><td>vector&lt;[16]x[16]xi8> of 8-bit signless integer values or vector&lt;[8]x[8]xi16> of 16-bit signless integer values or vector&lt;[4]x[4]xi32> of 32-bit signless integer values or vector&lt;[2]x[2]xi64> of 64-bit signless integer values or vector&lt;[1]x[1]xi128> of 128-bit signless integer values or vector&lt;[8]x[8]xf16> of 16-bit float values or vector&lt;[8]x[8]xbf16> of bfloat16 type values or vector&lt;[4]x[4]xf32> of 32-bit float values or vector&lt;[2]x[2]xf64> of 64-bit float values</td></tr><tr><td style=text-align:center><code>base</code></td><td>memref of any type values</td></tr><tr><td style=text-align:center><code>indices</code></td><td>index</td></tr></tbody></table><h3 id=arm_smezero-arm_smezeroop><code>arm_sme.zero</code> (arm_sme::ZeroOp)&nbsp;<a class=headline-hash href=#arm_smezero-arm_smezeroop>¶</a></h3><p><em>Initialize the two-dimensional ZA array with 0s</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arm_sme.zero` attr-dict `:` type($res)
</code></pre><p>Initialise ZA with 0. This operation is convenient wrapper for the SME
<code>zero</code> intrinsic and instruction.</p><p>Example 1: Zero an 8-bit element ZA tile.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> arm_sme<span class=p>.</span>zero <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>16</span><span class=p>]x[</span><span class=m>16</span><span class=p>]</span>xi8<span class=p>&gt;</span>
</span></span></code></pre></div><p>Example 2: Zero a 64-bit element ZA tile.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> arm_sme<span class=p>.</span>zero <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>2</span><span class=p>]x[</span><span class=m>2</span><span class=p>]</span>xi64<span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: AlwaysSpeculatableImplTrait</p><p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=results-5>Results:&nbsp;<a class=headline-hash href=#results-5>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>vector&lt;[16]x[16]xi8> of 8-bit signless integer values or vector&lt;[8]x[8]xi16> of 16-bit signless integer values or vector&lt;[4]x[4]xi32> of 32-bit signless integer values or vector&lt;[2]x[2]xi64> of 64-bit signless integer values or vector&lt;[1]x[1]xi128> of 128-bit signless integer values or vector&lt;[8]x[8]xf16> of 16-bit float values or vector&lt;[8]x[8]xbf16> of bfloat16 type values or vector&lt;[4]x[4]xf32> of 32-bit float values or vector&lt;[2]x[2]xf64> of 64-bit float values</td></tr></tbody></table><div class=edit-meta><br></div><nav class=pagination><a class="nav nav-prev" href=https://mlir.llvm.org/docs/Dialects/ArmNeon/ title="'arm_neon' Dialect"><i class="fas fa-arrow-left" aria-hidden=true></i> Prev - 'arm_neon' Dialect</a>
<a class="nav nav-next" href=https://mlir.llvm.org/docs/Dialects/ArmSVE/ title="'arm_sve' Dialect">Next - 'arm_sve' Dialect <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://mlir.llvm.org/>Home</a></li><li><a href=https://mlir.llvm.org/users/>Users of MLIR</a></li><li><a href=https://mlir.llvm.org/pubs/>MLIR Related Publications</a></li><li><a href=https://mlir.llvm.org/talks/>Talks</a></li><li><a href=https://mlir.llvm.org/deprecation/>Deprecations & Current Refactoring</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/getting_started/>Getting Started<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/getting_started/ReportingIssues/>Reporting Issues</a></li><li><a href=https://mlir.llvm.org/getting_started/Debugging/>Debugging Tips</a></li><li><a href=https://mlir.llvm.org/getting_started/Faq/>FAQ</a></li><li><a href=https://mlir.llvm.org/getting_started/Contributing/>How to Contribute</a></li><li><a href=https://mlir.llvm.org/getting_started/DeveloperGuide/>Developer Guide</a></li><li><a href=https://mlir.llvm.org/getting_started/openprojects/>Open Projects</a></li><li><a href=https://mlir.llvm.org/getting_started/Glossary/>Glossary</a></li><li><a href=https://mlir.llvm.org/getting_started/TestingGuide/>Testing Guide</a></li></ul></li><li class="parent has-sub-menu"><a href=https://mlir.llvm.org/docs/>Code Documentation<span class="mark opened">-</span></a><ul class=sub-menu><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Bindings/>Bindings<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Bindings/Python/>MLIR Python Bindings</a></li></ul></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tools/>Tools<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tools/MLIRLSP/>MLIR : Language Server Protocol</a></li><li><a href=https://mlir.llvm.org/docs/Tools/mlir-reduce/>MLIR Reduce</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/ActionTracing/>Action: Tracing and Debugging MLIR-based Compilers</a></li><li><a href=https://mlir.llvm.org/docs/BufferDeallocationInternals/>Buffer Deallocation - Internals</a></li><li><a href=https://mlir.llvm.org/docs/Bufferization/>Bufferization</a></li><li><a href=https://mlir.llvm.org/docs/DataLayout/>Data Layout Modeling</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/DefiningDialects/>Defining Dialects<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/DefiningDialects/AttributesAndTypes/>Defining Dialect Attributes and Types</a></li><li><a href=https://mlir.llvm.org/docs/DefiningDialects/Operations/>Operation Definition Specification (ODS)</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Diagnostics/>Diagnostic Infrastructure</a></li><li><a href=https://mlir.llvm.org/docs/DialectConversion/>Dialect Conversion</a></li><li class="parent has-sub-menu"><a href=https://mlir.llvm.org/docs/Dialects/>Dialects<span class="mark opened">-</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Dialects/FuncTransformOps/></a></li><li><a href=https://mlir.llvm.org/docs/Dialects/OpenACCDialect/>'acc' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Affine/>'affine' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/AMDGPU/>'amdgpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/AMX/>'amx' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArithOps/>'arith' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArmNeon/>'arm_neon' Dialect</a></li><li class=active><a href=https://mlir.llvm.org/docs/Dialects/ArmSME/>'arm_sme' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArmSVE/>'arm_sve' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/AsyncDialect/>'async' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/BufferizationOps/>'bufferization' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ControlFlowDialect/>'cf' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ComplexOps/>'complex' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/DLTIDialect/>'dlti' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/EmitC/>'emitc' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Func/>'func' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/GPU/>'gpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/IndexOps/>'index' Dialect</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Dialects/Linalg/>'linalg' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Dialects/Linalg/OpDSL/>Linalg OpDSL</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Dialects/LLVM/>'llvm' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MathOps/>'math' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MemRef/>'memref' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MLProgramOps/>'ml_program' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/NVGPU/>'nvgpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/NVVMDialect/>'nvvm' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/OpenMPDialect/>'omp' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/PDLInterpOps/>'pdl_interp' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/PDLOps/>'pdl' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/QuantDialect/>'quant' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ROCDLDialect/>'rocdl' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SCFDialect/>'scf' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ShapeDialect/>'shape' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SparseTensorOps/>'sparse_tensor' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/TensorOps/>'tensor' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/UBOps/>'ub' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Vector/>'vector' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/X86Vector/>'x86vector' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Builtin/>Builtin Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MatchOpInterfaces/>OpInterface definitions</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SPIR-V/>SPIR-V Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/TOSA/>Tensor Operator Set Architecture (TOSA) Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Transform/>Transform Dialect</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Interfaces/>Interfaces</a></li><li><a href=https://mlir.llvm.org/docs/TargetLLVMIR/>LLVM IR Target</a></li><li><a href=https://mlir.llvm.org/docs/BytecodeFormat/>MLIR Bytecode Format</a></li><li><a href=https://mlir.llvm.org/docs/CAPI/>MLIR C API</a></li><li><a href=https://mlir.llvm.org/docs/LangRef/>MLIR Language Reference</a></li><li><a href=https://mlir.llvm.org/docs/ReleaseNotes/>MLIR Release Notes</a></li><li><a href=https://mlir.llvm.org/docs/Canonicalization/>Operation Canonicalization</a></li><li><a href=https://mlir.llvm.org/docs/PassManagement/>Pass Infrastructure</a></li><li><a href=https://mlir.llvm.org/docs/Passes/>Passes</a></li><li><a href=https://mlir.llvm.org/docs/PatternRewriter/>Pattern Rewriting : Generic DAG-to-DAG Rewriting</a></li><li><a href=https://mlir.llvm.org/docs/PDLL/>PDLL - PDL Language</a></li><li><a href=https://mlir.llvm.org/docs/Quantization/>Quantization</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Rationale/>Rationale<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Rationale/RationaleGenericDAGRewriter/>Generic DAG Rewriter Infrastructure Rationale</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/RationaleLinalgDialect/>Linalg Dialect Rationale: The Case For Compiler-Friendly Custom Operations</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/Rationale/>MLIR Rationale</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/MLIRForGraphAlgorithms/>MLIR: Incremental Application to Graph Algorithms in ML Frameworks</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/RationaleSimplifiedPolyhedralForm/>MLIR: The case for a simplified polyhedral form</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/SideEffectsAndSpeculation/>Side Effects & Speculation</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/UsageOfConst/>Usage of 'const' in MLIR, for core IR types</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/ShapeInference/>Shape Inference</a></li><li><a href=https://mlir.llvm.org/docs/SPIRVToLLVMDialectConversion/>SPIR-V Dialect to LLVM Dialect conversion manual</a></li><li><a href=https://mlir.llvm.org/docs/SymbolsAndSymbolTables/>Symbols and Symbol Tables</a></li><li><a href=https://mlir.llvm.org/docs/DeclarativeRewrites/>Table-driven Declarative Rewrite Rule (DRR)</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Traits/>Traits<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Traits/Broadcastable/>The `Broadcastable` Trait</a></li></ul></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tutorials/>Tutorials<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tutorials/CreatingADialect/>Creating a Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/QuickstartRewrites/>Quickstart tutorial to adding MLIR graph rewrite</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tutorials/Toy/>Toy Tutorial<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-1/>Chapter 1: Toy Language and AST</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-2/>Chapter 2: Emitting Basic MLIR</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-3/>Chapter 3: High-level Language-Specific Analysis and Transformation</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-4/>Chapter 4: Enabling Generic Transformation with Interfaces</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-5/>Chapter 5: Partial Lowering to Lower-Level Dialects for Optimization</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-6/>Chapter 6: Lowering to LLVM and CodeGeneration</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-7/>Chapter 7: Adding a Composite Type to Toy</a></li></ul></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tutorials/transform/>Transform Dialect Tutorial<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch0/>Chapter 0: A Primer on “Structured” Linalg Operations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch1/>Chapter 1: Combining Existing Transformations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch2/>Chapter 2: Adding a Simple New Transformation Operation</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch3/>Chapter 3: More than Simple Transform Operations</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Tutorials/UnderstandingTheIRStructure/>Understanding the IR Structure</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/DataFlowAnalysis/>Writing DataFlow Analyses in MLIR</a></li></ul></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i>
<i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>